import profile
import setup_path
import airsim
import numpy as np
import time
import matplotlib.pyplot as plt
import geopy.distance
from math import pi, sqrt, pow, atan2, asin, sin, cos
from scipy.optimize import fsolve
from threading import Thread

# D:\Documents\AirSim contains settings.json folder


class DronePowerModel:
    # This class models the power consumption of a drone during flight and hover 
    # for single drones and drones in swarms. 
    # It includes methods for calculating various aspects of drone energy usage 
    # based on flight dynamics and environmental factors.
    
   
    DEBUG = True
    # A class variable that controls the output of debug statements. 
    # Set to False to disable debug print statements throughout the class.

    def __init__(self):
        # Constructor for the DronePowerModel class. 
        # It initializes the class by assigning constants used in power calculations.
        # These constants are set by the 'assign_constants' method.
        self.assign_constants()
        # self.config_file_path = config_file
    
    # ########################## #
    # Energy Model of Quadcopter # 
    # ########################## #     
    # This section contains methods related to the energy model of a quadcopter.

    ####################
    # Getter Functions #
    ####################
    # These functions are used to retrieve various parameters related to the drone, 
    # such as velocity, acceleration, etc.

    def get_drone_velocity(self, drone):
        """
        Retrieves the velocity of the drone in the local NED (North-East-Down) frame.
        This method returns the velocity in meters per second (m/s).
        :param drone: The drone object whose velocity is being queried.
        :return: A NumPy array representing the drone's velocity in the NED frame.
        """
        # gets the velocity at which the drones are traveling
        if DronePowerModel.DEBUG:
            print("\nVerifying Drone Velocity", self.airsim_state[drone]['MultiRotorState'].kinematics_estimated)
        kinematics = self.airsim_state[drone]['MultiRotorState'].kinematics_estimated
        velocity_drone = [kinematics.linear_velocity.x_val, kinematics.linear_velocity.y_val, kinematics.linear_velocity.z_val]
        return np.array(velocity_drone)
    

    def get_air_speed(self, drone):
        """
        Calculates the air speed of the drone in meters per second (m/s).
        The air velocity is the difference between the ground velocity of the drone and the wind velocity.
        :param drone: The drone object for which air speed is being calculated.
        :return: The air velocity of the drone in m/s.
        """
        # Velocity_Air = ||V_air|| = || V_ground (velocity drone is travelling) - V_wind ||
        velocity_ground = self.get_drone_velocity(drone)
        velocity_air = np.linalg.norm(velocity_ground - self.wind_vector) # TODO: mention to alain airspeed
        return velocity_air


    def get_net_thrust(self, drone):
        """
        Calculates the net thrust generated by all four propellers of the drone.
        The thrust is computed in Newtons, a unit of force (kg * m/s^2).
        :param drone: The drone name for which net thrust is being calculated.
        :return: The total net thrust produced by the drone's propellers in Newtons.
        """
        rotor_states = self.airsim_state[drone]["RotorState"] 
        net_thrust = 0
        for rotor in rotor_states.rotors:
            net_thrust += rotor['thrust']
        if DronePowerModel.DEBUG:
            print("\nNet_thrust:", net_thrust, "for Drone:", drone)
        return net_thrust
    

    def get_thrust_propellers(self, drone):
        """
        Retrieves the thrust generated by each of the four propellers of the drone.
        This method returns the thrust values in an array, with each value in Newtons.
        :param drone: The drone object for which thrust values are being retrieved.
        :return: A NumPy array containing the thrust values of each propeller in Newtons.
        """
        rotor_states = self.airsim_state[drone]["RotorState"] 
        thrust = []
        for rotor in rotor_states.rotors:
            thrust.append(rotor['thrust'])
        if DronePowerModel.DEBUG:
            print("\nThrust:", thrust, "for Drone:", drone)
            print("RotorStates", rotor_states.rotors, "for Drone:", drone)
        return np.array(thrust)


    def get_angular_speed(self, drone):
        """
        Calculates the angular speed of each of the four propellers of the drone.
        The speed is measured in revolutions per minute (rpm).
        :param drone: The drone object for which angular speeds are being calculated.
        :return: A NumPy array containing the angular speeds of each propeller in rpm.
        """
        rotor_states = self.airsim_state[drone]["RotorState"] 
        speed = []
        for rotor in rotor_states.rotors:
            speed.append(rotor['speed'])
        if DronePowerModel.DEBUG:
            print("\nAngular speed:", speed, "for Drone:", drone)
        return np.array(speed)


    def get_drone_orientation(self, drone):
        """
        Retrieves the orientation of the drone in terms of roll, pitch, and yaw.
        The orientation is provided in both radians and degrees. Pitch is the Alpha 
        angle and Yaw is the Beta angle
        :param drone: The drone name for which orientation is being calculated.
        :return: A dictionary containing roll, pitch, and yaw in both radians and degrees.
        """
        drone_pose = self.airsim_state[drone]["PoseWFNED"]
        w = drone_pose.orientation.w_val
        x = drone_pose.orientation.x_val
        y = drone_pose.orientation.y_val
        z = drone_pose.orientation.z_val
        
        roll_x_rad, pitch_y_rad, yaw_z_rad = self.euler_from_quaternion(x, y, z, w) # radians
        roll_x_deg, pitch_y_deg, yaw_z_deg = np.rad2deg(roll_x_rad), np.rad2deg(pitch_y_rad), np.rad2deg(yaw_z_rad) # degrees
        return {"radians": [roll_x_rad, pitch_y_rad, yaw_z_rad], "degrees": [roll_x_deg, pitch_y_deg, yaw_z_deg]}
        
    
    def get_induced_velocity(self, drone):
        """
        Calculates the induced velocity of the drone, which differs based on its flight mode.
        Their are currently two modes 'Hover' and 'Flight' with each different calculations
        :param drone: The drone name for which induced velocity is being calculated.
        :return: The induced velocity of the drone in meters per second (m/s).
        """
        # Calculate induced velocity when hovering
        if self.drone_flight_mode == "Hover":
            # velocity_induced = sqrt( Thrust / 2 * air_density * A (Total Area Covered By Propellers) )
            # A = M * pi * R^2 
            # M is nuber of propellers
            # R is radius of propellers
            thrust = self.get_net_thrust(drone)
            air_density = self.airsim_state[drone]["AirDensity"] # kg/m^3
            velocity_induced = sqrt( thrust / (2 * air_density * self.A) ) # meters per second (m/s)
            return velocity_induced
        elif self.drone_flight_mode == "Flight":
            # Induced velocity we can represent as the ground velocity of the drone while in flight.
            velocity_induced = self.get_drone_velocity(drone) # m/s
            return velocity_induced
            #thrust = self.get_net_thrust(drone) # N = Kg * m/s^2
            #prop_area = self.A # m^2
            #orientation = self.get_drone_orientation(drone)
            #alpha = orientation['radians'][1] # gets pitch aka angle of attack radians
            #beta = orientation['radians'][2] # gets yaw aka beta/steering angle randians
            #air_density = self.airsim_state[drone]["AirDensity"] # self.airsim_client.simGetGroundTruthEnvironment(drone).air_density
            #numerator = thrust/(2 * air_density * prop_area)
            #velocity_air = self.get_velocity_air(drone) # m/s
            #projection_jk = sqrt( ( pow(sin(alpha), 2) * pow(sin(beta), 2) - pow(sin(beta), 2) ) / (pow(sin(alpha), 2) * pow(sin(beta), 2) - 1) )
            #projection_ij = sqrt( ( pow(sin(alpha), 2) * pow(sin(beta), 2) - pow(sin(alpha), 2) ) / (pow(sin(alpha), 2) * pow(sin(beta), 2) - 1) )
            #projection_ik = ( cos(alpha) * cos(beta) ) / sqrt( pow(sin(alpha), 2) * pow(cos(beta), 2) + pow(cos(alpha), 2) )  
            #denom_term1 = (velocity_air * projection_jk)**2
            #denom_term2 = (velocity_air * projection_ik)**2
            #denom_term3_part1 = velocity_air * projection_ij
            #velocity_induced_hover = sqrt( thrust / (2 * air_density * self.A) ) # m/s # TODO: Assumption that  velocity induced would be a good enough approximation
            #velocity_induced_flight = numerator / sqrt( denom_term1 + denom_term2 + (denom_term3_part1 + velocity_induced_hover)**2 ) 
            #return velocity_induced_flight # m/s
        

    #def get_wind_heading(self):
    #    """ 
    #        Returns Direction relative to drone in the swarm 
    #    """        
    #    n,e,d = self.wind_vector
    #    wind_direction = atan2(e, n)
    #    orientation = self.get_drone_orientation(drone)
    #    beta = orientation['radians'][2] # gets yaw aka beta/steering/heading angle randians
        
        
    def get_swarm_parasitic_power_consumption(self):
        """
        Computes the total power consumption in Watts given a particular formation and wind vector.
        The calculation takes into account various factors such as formation, wind, thrust, drag, and velocity.
        :return: The total power consumption of the swarm formation in Watts.
        """
        
        wind_speed = np.linalg.norm(self.wind_vector)
        wind_direction = self.wind_direction # East+, North+, North-
        # Assigns sign of wind direction
        wind_velocity = wind_speed
        if wind_direction == "North-":
            wind_velocity = -1 * wind_speed
        
        if DronePowerModel.DEBUG:
            print("Parasitic Power (Flight Mode) Pt2: ", 
                    "\nWind Speed (m/s):", wind_speed,
                    "\nWind Direction (NED):", wind_direction,
                    "\nWind Velocity (m/s):", wind_velocity,
                    "\n Formation Type:", self.formation, "\n"
                    )
            
        if self.formation == "Vee":
            # Cubic estimation of power-x
            a_x , b_x, c_x, d_x = (0.04992735, -0.03668969, 4.85183825, 2.86950829)
            # Quadratic stimation for power-z
            a_z , b_z, c_z = (0.53830656, -3.10909162,  4.6096633)
            if wind_direction == "East+":
                return self.quadratic(wind_velocity, a_z , b_z, c_z)
            else:
                return self.cubic(wind_velocity, a_x , b_x, c_x, d_x)
        elif self.formation == "Echelon":
            # Cubic estimation of power-x
            a_x , b_x, c_x, d_x = (0.06068811, -0.06580198, 4.25524982, 1.32457763)
            # Quadratic stimation for power-z
            a_z , b_z, c_z = (0.74663132, -4.73078804, 6.92984925)
            if wind_direction == "East+":
                return self.quadratic(wind_velocity, a_z , b_z, c_z)
            else:
                return self.cubic(wind_velocity, a_x , b_x, c_x, d_x)
    

    def get_drag_force(self):
        """
        Calculates the drag force experienced by the drone swarm, based on its formation and wind vector.
        The drag force on the swarm is estimated using cubic and quadratic estimations from solid works drag simulations.
        :return: The drag force experienced by the drone in Newtons.
        """
        wind_speed = np.linalg.norm(self.wind_vector)
        wind_direction = "Front" # Front, Left, Right we need a function that returns this
        # Assigns sign of wind direction
        wind_velocity = wind_speed
        if wind_direction == "Left":
            wind_velocity = -1 * wind_speed
            
        if self.formation == "Vee":
            # Cubic estimation of drag-x
            a_x , b_x, c_x, d_x = (0.00118268, -0.00188352, 0.71607042, 0.17407187)
            # Quadratic stimation for drag-z
            a_z , b_z, c_z = (0.0291959, 0.05643199, -0.07195437)
            if wind_direction == "Front":
                return self.quadratic(wind_velocity, a_z , b_z, c_z)
            else:
                return self.cubic(wind_velocity, a_x , b_x, c_x, d_x)
        elif self.formation == "Echelon":
            # Cubic estimation of drag-x
            a_x , b_x, c_x, d_x = (0.0018127, -0.00320426, 0.67314954, 0.07652908)
            # Quadratic stimation for drag-z
            a_z , b_z, c_z = (0.0405097677, -0.0111972537, -0.00000343289225)
            if wind_direction == "Front":
                return self.quadratic(wind_velocity, a_z , b_z, c_z)
            else:
                return self.cubic(wind_velocity, a_x , b_x, c_x, d_x)

    ####################
    # Setter Functions #
    ####################

    def set_operation_state(self, state):
        """
        Sets the operational state of the drone, either 'Hover' or 'Flight'.
        This state affects various calculations within the class.
        :param state: The operation state to be set for the drone ('Hover' or 'Flight').
        """
        self.drone_flight_mode = state
        
        
    def set_wind_vector(self, wind_vector):
        """
        Sets the current wind vector that affects the drone and swarm. 
        The wind vector is specified in the NED (North-East-Down) coordinate system,
        this is the airsim world NED.
        :param wind_vector: The wind vector to be set, represented as a NumPy array or a list (N,E,D).
        """
        self.wind_vector = wind_vector
     
        
    def set_formation(self, formation):
        """
        Specifies the formation in which the drones are flying, such as 'Echelon', 'Vee', etc.
        The formation type may affect various calculations related to aerodynamics and power consumption.
        :param formation: A string representing the name of the formation.
        """
        self.formation = formation
        
    def set_drones_in_swarm(self, drones_in_swarm):
        """
        Assigns the number of drones that are part of the swarm.
        This information is used in calculations that depend on the number of drones in operation.
        :param drones_in_swarm: The number of drones in the swarm.
        """
        self.drones_in_swarm = drones_in_swarm
        
    ###################################
    # Polynomial Regression Functions #
    ###################################

    def linear(self, x, a, b):
        """
        A linear polynomial function used for various calculations within the class.
        :param x: The independent variable.
        :param a: The coefficient of x.
        :param b: The constant term.
        :return: The result of the linear polynomial a*x + b.
        """
        return a*x + b
    
    
    def quadratic(self, x, a, b, c):
        """
        A quadratic polynomial function used for various calculations within the class.
        :param x: The independent variable.
        :param a: The coefficient of x^2.
        :param b: The coefficient of x.
        :param c: The constant term.
        :return: The result of the quadratic polynomial a*x^2 + b*x + c.
        """
        return a*x**2 + b*x + c
    
    
    def cubic(self, x, a, b, c, d):
        """
        A cubic polynomial function used for various calculations within the class.
        :param x: The independent variable.
        :param a: The coefficient of x^3.
        :param b: The coefficient of x^2.
        :param c: The coefficient of x.
        :param d: The constant term.
        :return: The result of the cubic polynomial a*x^3 + b*x^2 + c*x + d.
        """
        return a*x**3+b*x**2+c*x + d

    ##################
    # Misc Functions #
    ##################

    def rpm_to_mps(self, rpm):
        """
        Converts revolutions per minute (rpm) to meters per second (m/s).
        This conversion is useful for translating propeller speed to linear velocity.
        :param rpm: The rotational speed in revolutions per minute.
        :return: The equivalent linear speed in meters per second.
        """
        return self.R * ((2 * pi)/60) * rpm


    def euler_from_quaternion(self, x, y, z, w):
        """
            Convert a quaternion into euler angles (roll, pitch, yaw)
            roll is rotation around x in radians (counterclockwise)
            pitch is rotation around y in radians (counterclockwise)
            yaw is rotation around z in radians (counterclockwise)
            Source: https://automaticaddison.com/how-to-convert-a-quaternion-into-euler-angles-in-python/
        """
        t0 = +2.0 * (w * x + y * z)
        t1 = +1.0 - 2.0 * (x * x + y * y)
        roll_x = atan2(t0, t1)
     
        t2 = +2.0 * (w * y - z * x)
        t2 = +1.0 if t2 > +1.0 else t2
        t2 = -1.0 if t2 < -1.0 else t2
        pitch_y = asin(t2)
     
        t3 = +2.0 * (w * z + x * y)
        t4 = +1.0 - 2.0 * (y * y + z * z)
        yaw_z = atan2(t3, t4)
     
        return roll_x, pitch_y, yaw_z # in radians        


    def calculate_projection(self, drone):
        """
        Computes the projection \(p_l\) of the specified drone.
        This involves calculations based on the drone's pitch (angle of attack) and yaw (steering angle).
        :param drone: The drone name for which the projection is being calculated.
        :return: The calculated projection value.
        """
        orientation = self.get_drone_orientation(drone)
        alpha = orientation['radians'][1] # gets pitch aka angle of attack
        beta = orientation['radians'][2] # gets yaw aka beta/steering angle
        # Formula for projection is 
        # sqrt( (sin(alpha)^2 * sin(beta)^2 - sin(alpha)^2) / (sin(alpha)^2 * sin(beta)^2 - 1) )
        numerator = pow(sin(alpha), 2) * pow(sin(beta), 2) - pow(sin(alpha), 2)
        denominator = pow(sin(alpha), 2) * pow(sin(beta), 2) - 1
        quotient = numerator/denominator
        projection = sqrt(quotient)
        return projection


    def assign_constants(self):
        """
        Assigns all constants used by the class. This method initializes 
        various parameters related to the drone's physical and aerodynamic 
        properties. Constants include the number of propeller blades,
        radius of propellers, area of the propeller, blade chord width,
        and drag coefficient of the blade.
        """
        # TODO: Read a config file to get these constants
        self.M = 4                              # Number of propeller blades
        self.R = 0.12                           # Radius of propellers in meters (m)
        self.A = self.M * pi * pow(self.R, 2)   # Area of the propeller m^2
        self.N = 2                              # Number of blades per propeller        
        self.c = 0.0157                         # blade chord width in meters(m) 
        self.cd_blade = 0.012                   # drag coefficient of blade, unitless   
    
    #####################    
    # Power Computation #
    #####################

    def induced_power(self, drone):
        """
        Computes the induced power of the drone, which is the 
        power required to overcome the force of gravity and 
        keep the aircraft airborne. The calculation differs 
        based on whether the drone is hovering or in flight.
        In 'Hover' mode, induced power is calculated as the 
        product of net rotor thrust and velocity induced.
        In 'Flight' mode, it considers additional factors 
        like air velocity and projection of the quad body.
        
        :param drone: The drone name for which induced power 
        is being calculated.
        
        :return: The induced power required for the drone's 
        current operation mode, measured in Watts (W).
        """
        if self.drone_flight_mode == "Hover":
            # Induced Power When hovering
            # Formula: P_induced = Thrust * Velocity_Induced
            net_rotor_thrust = self.get_net_thrust(drone)
            velocity_induced = self.get_induced_velocity(drone)
            induced_power = net_rotor_thrust * velocity_induced
            if DronePowerModel.DEBUG:
                print("Induced Power (Flight Mode):", drone,
                      "\nNet Thrust(N):", net_rotor_thrust,
                      "\nVelocity Induced (m/s):", velocity_induced,
                      "\nInduced Power (W):", induced_power, "\n"
                      )
            return induced_power
        elif self.drone_flight_mode == "Flight":
            # Induced Power When In Flight
            # Induced_Power = Thrust(N) * (Velocity_Air * Projection_Quad_Body + Velocity_Induced)
            # Watts (joules/second -> work/time -> Force * Displacemnt / Time) 
            # = Newtons(N) * (m/s * projection (unitless, angles in radians) * m/s)
            net_rotor_thrust = self.get_net_thrust(drone)   # Newtons Kg * m/s^2
            velocity_air = self.get_air_speed(drone)     # m/s
            projection = self.calculate_projection(drone)   # unitless
            velocity_induced = self.get_induced_velocity(drone) # m/s
            induced_power = net_rotor_thrust * (velocity_air * projection + velocity_induced)
            if DronePowerModel.DEBUG:
                print("Induced Power (Flight Mode):", drone,
                      "\nNet Thrust(N):", net_rotor_thrust,
                      "\nAir Velocity(m/s):", velocity_air,
                      "\nProjetion (unitless):", projection,
                      "\nVelocity Induced (m/s):", velocity_induced,
                      "\nInduced Power (W):", induced_power, "\n"
                      )
            return induced_power
    

    def profile_power(self, drone):
        """
        Calculates the profile power of the drone, which is the power consumed 
        due to the aerodynamic drag on the rotating propeller blades.
        The calculation is based on various factors including thrust, air density, 
        angular speed of propellers, and drone orientation.
        :param drone: The drone name for which profile power is being calculated.
        :return: The profile power of the drone in Watts (W).
        """
        air_density = self.airsim_state[drone]["AirDensity"] # kg/m^3
        if self.drone_flight_mode == "Hover":
            # Profile Power calculation for hover of all propellers
            # (N * c * cd_blade * air_density * R^4) / 8 * angular_speed^3
            avg_angular_velocity_rpm = np.mean(self.get_angular_speed(drone))
            avg_angular_velocity_mps = self.rpm_to_mps(avg_angular_velocity_rpm)
            avg_angular_speed_mps = abs(avg_angular_velocity_mps)
            profile_power = ( ( self.N * self.c * self.cd_blade * air_density * pow(self.R, 4) ) / ( 8 * pow(avg_angular_speed_mps, 3) ) )
            if DronePowerModel.DEBUG:
                print("Profile Power (Hover Mode):", drone, 
                      "\nAir Density (kg/m^3):", air_density,
                      "\nAverage Angular Speed (m/s):", avg_angular_speed_mps,
                      "\nNumber of Blades:", self.N,
                      "\nChord Length (m):", self.c,
                      "\nBlade Drag Coefficient:", self.cd_blade,
                      "\nBlade Radius (m):", self.R,
                      "\nProfile Power (W):", profile_power, "\n"
                      )
            return profile_power
        elif self.drone_flight_mode == "Flight":
            # C2 = (N * c * cd_blade * air_density * R^4) / 8*k^(3/2)
            # C3 = (N * c * cd_blade * air_density * R^2) / 8*k^(3/2)
            # k = Thrust/(angular speed)^2 # TODO K is calculated at an instant rather than through experiments
            # profile_power = C2*T^(3/2) + C3 * (Vair_jk^2 + Vair_ik^2) * T^(1/2)
            #     
            thrust = self.get_net_thrust(drone)
            avg_angular_velocity_rpm = np.mean(self.get_angular_speed(drone))
            avg_angular_velocity_mps = self.rpm_to_mps(avg_angular_velocity_rpm)
            avg_angular_speed_mps = abs(avg_angular_velocity_mps)
            k = thrust/(avg_angular_speed_mps**2)
            c2 = (self.N * self.c * self.cd_blade * air_density * self.R**4) / (8 * k**(3/2))
            c3 = (self.N * self.c * self.cd_blade * air_density * self.R**2) / (8 * k**(1/2))
            orientation = self.get_drone_orientation(drone)
            alpha = orientation['radians'][1] # gets pitch aka angle of attack radians
            beta = orientation['radians'][2] # gets yaw aka beta/steering angle randians
            projection_jk = sqrt( ( pow(sin(alpha), 2) * pow(sin(beta), 2) - pow(sin(beta), 2) ) / (pow(sin(alpha), 2) * pow(sin(beta), 2) - 1) )
            projection_ik = ( cos(alpha) * cos(beta) ) / sqrt( pow(sin(alpha), 2) * pow(cos(beta), 2) + pow(cos(alpha), 2) )  
            profile_power = c2 * thrust**(3/2) + c3 * (projection_jk**2 + projection_ik**2) * thrust**(1/2)
            if DronePowerModel.DEBUG:
                print("Profile Power (Flight Mode):", drone,
                      "\nAir Density (kg/m^3):", air_density,
                      "\nAverage Angular Speed (m/s):", avg_angular_speed_mps,
                      "\nNumber of Blades:", self.N,
                      "\nChord Length (m):", self.c,
                      "\nBlade Drag Coefficient:", self.cd_blade,
                      "\nBlade Radius (m):", self.R,
                      "\nAlpha Angle (rad):", alpha,
                      "\nBeta Angle (rad):", beta,
                      "\nProjection on jk-plane:", projection_jk,
                      "\nProjection on ik-plane:", projection_ik,
                      "\nk coefficient:", k,
                      "\nProfile Power (W):", profile_power, "\n"
                      )
            return profile_power
            
    
    def parasitic_power(self, mode, drone_name=""):
        """
        Calculates the parasitic power, which is the power consumed due to 
        aerodynamic drag force on the drone.This method can calculate the 
        parasitic power for either a single drone or the entire swarm. 
        Do not use this to calculate individual drone drag while in a swarm.
        :param mode: A string indicating whether to calculate for the entire 'Swarm' or a 'Single Drone'.
        :param drone_name: The name of the drone, required if 'mode' is set to 'Single Drone'.
        :return: The parasitic power consumption in Watts.
        """
        if mode == "Swarm":
            if self.drone_flight_mode == "Hover":
                # Formula: F_Drag * Air_velocity = 0.5 * Coef_drag * air_density * A_ref * Air_velocity^3
                coef_drag = 1.139 # TODO Follow up and verify this is good
                A_ref = 0.015 # Gathered from CAD model projection m^2
                net_parasitic_power = 0
                if DronePowerModel.DEBUG:
                    print("Parasitic Power (Swarm Hover Mode): ")
                for drone in self.drones_in_swarm:
                    velocity_air = self.get_air_speed(drone)
                    air_density = self.airsim_state[drone]["AirDensity"]
                    parasitic_power = 0.5 * coef_drag * air_density * A_ref * pow(velocity_air, 3)
                    net_parasitic_power += parasitic_power
                    if DronePowerModel.DEBUG:
                        print("Drone:", drone,
                         "\nAir Velocity (m/s):", velocity_air, 
                        "\nParasitic Power of Drone (W):", parasitic_power
                        )
                if DronePowerModel.DEBUG:
                    print("Air Density (kg/m^3):", air_density,
                          "\ncoef_drag:", coef_drag,
                          "\nA_ref (m^2):", A_ref,
                          "\nNet Parasitic Power (W):", net_parasitic_power, "\n"
                          )
                return net_parasitic_power
            elif self.drone_flight_mode == "Flight":
                # Formula: F_Drag * Air_velocity = 0.5 * Coef_drag * air_density * A_ref * Air_velocity^3
                # We use a polynomial function that fits the data collected of the drone swarm to get the formula results above
                parasitic_power = self.get_swarm_parasitic_power_consumption()
                if DronePowerModel.DEBUG:
                    print("Parasitic Power (Swarm Flight Mode): ", 
                          "\nParasitic Power (W):", parasitic_power, "\n"
                          )
                return parasitic_power
        elif mode == "Single Drone":
            if self.drone_flight_mode == "Hover":
                # Formula: F_Drag * Air_velocity = 0.5 * Coef_drag * air_density * A_ref * Air_velocity^3
                coef_drag = 1.139 # TODO Follow up and verify this is good
                air_density = self.airsim_state[drone_name]["AirDensity"]
                A_ref = 0.015 # Gathered from CAD model projection m^2
                velocity_air = self.get_air_speed(drone_name)
                parasitic_power = 0.5 * coef_drag * air_density * A_ref * pow(velocity_air, 3)
                if DronePowerModel.DEBUG:
                    print("Parasitic Power (Single Drone Hover Mode):",
                          "\nDrone:", drone_name,
                          "\nAir Velocity (m/s):", velocity_air,
                          "Air Density (kg/m^3):", air_density,
                          "\ncoef_drag:", coef_drag,
                          "\nA_ref (m^2):", A_ref,
                          "\nNet Parasitic Power (W):", parasitic_power, "\n"
                          )
                return parasitic_power
            elif self.drone_flight_mode == "Flight":
                # Formula: F_Drag * Air_velocity = 0.5 * Coef_drag * air_density * A_ref * Air_velocity^3
                # We use a polynomial function that fits the data collected of the drone swarm to get the formula results above
                # parasitic_power = self.get_parasitic_power()
                # if DronePowerModel.DEBUG:
                #    print("Parasitic Power (Swarm Flight Mode): ", 
                #          "\nParasitic Power (W):", parasitic_power, "\n"
                #          )
                # return parasitic_power
                # TODO Implement
                pass


    def drone_power_consumption_model(self, operation_mode, wind_vector, wind_direction, drone, airsim_state):
        """
        Computes the power consumption of a single drone, ideally called at a rate of once per second.
        This method calculates the total power consumption based on various factors, 
        including the drone's operation mode, wind conditions, and its current state.

        :param operation_mode: The operation mode of the drone, such as 'Hover' or 'Flight'.
        :param wind_vector: The current wind vector, which affects the drone's power consumption.
        :param wind_direction: The direction of the wind, which can be 'Front', 'Left', or 'Right'.
        :param drone: The specific drone object for which power consumption is being calculated.
        :param airsim_state: The current state of the AirSim environment, which provides necessary data for the calculations.

        :return: The total power consumption of the specified drone in Watts.
        The total power is the sum of induced power, profile power, and parasitic power, which vary based 
        on whether the drone is in 'Hover' or 'Flight' mode.
        """ 
        self.set_operation_state(operation_mode)
        self.set_wind_vector(wind_vector) # Create a function to extract and return wind direction 
        self.wind_direction = wind_direction # Front, Left, Right
        self.airsim_state = airsim_state
        # This computes total_power(drone_i) = induced_power(drone_i) + profile_power(drone_i) for flight mode
        # Computes total_power(drone_i) = induced_power(drone_i) + profile_power(drone_i) + parasitic_power(drone_i) for flight mode
        # The result at this step should be summation of all power of drones in swarm 
        total_power = 0
        if self.drone_flight_mode == "Hover":
            total_power += self.induced_power(drone) + self.profile_power(drone) + self.parasitic_power("Single Drone", drone_name=drone)
            if DronePowerModel.DEBUG:
                print("Total Power (Mode Hover)(Single):", total_power, "Watts", "\n")
        elif self.drone_flight_mode == "Flight":
            total_power += self.induced_power(drone) + self.profile_power(drone) + self.parasitic_power("Single Drone", drone_name=drone)
            if DronePowerModel.DEBUG:
                print("Total Power (Mode Flight)(Single):", total_power, "Watts", "\n")
        return total_power
    
    
    def swarm_power_consumption_model(self, operation_mode, formation, wind_vector, wind_direction, drones_in_swarm, airsim_state):
        """
        Models the power consumption of an entire drone swarm.
        This method takes into account various factors like operation mode, formation, 
        wind conditions, and the number of drones. This method returns total Watts
        so it should be called at a rate of once per second.
        :param operation_mode: The operation mode of the drones ('Hover' or 'Flight').
        :param formation: The formation in which the drones are flying.
        :param wind_vector: The wind vector affecting the drones.
        :param wind_direction: The direction of the wind.
        :param drones_in_swarm: The number of drones in the swarm.
        :param airsim_state: The current state of the AirSim environment.
        :return: The total power consumption of the swarm in Watts.
        """
        self.set_operation_state(operation_mode)
        self.set_wind_vector(wind_vector) # Create a function to extract and return wind direction 
        self.wind_direction = wind_direction # Front, Left, Right
        self.set_drones_in_swarm(drones_in_swarm)
        self.set_formation(formation)
        self.airsim_state = airsim_state
        # This computes total_power(drone_i) = induced_power(drone_i) + profile_power(drone_i) for flight mode
        # Computes total_power(drone_i) = induced_power(drone_i) + profile_power(drone_i) + parasitic_power(drone_i) for flight mode
        # The result at this step should be summation of all power of drones in swarm 
        total_power = 0
        if self.drone_flight_mode == "Hover":
            for drone in drones_in_swarm:
                total_power += (self.induced_power(drone) + self.profile_power(drone))
            total_power += self.parasitic_power("Swarm")
            if DronePowerModel.DEBUG:
                print("Total Power (Mode Hover)(Swarm):", total_power, "Watts", "\n")
        elif self.drone_flight_mode == "Flight":
            for drone in drones_in_swarm:
                total_power += (self.induced_power(drone) + self.profile_power(drone))
            total_power += self.parasitic_power("Swarm")
            if DronePowerModel.DEBUG:
                print("Total Power (Mode Flight)(Swarm):", total_power, "Watts", "\n")
        return total_power        


class WindModel:

    DEBUG = True
    
    def __init__(self, wind_vector=[0,0,0]):
        """  """
        self.wind_vector = np.array(wind_vector)
    

    def calculate_relative_wind_direction(self, wind_velocity, drone_velocity):
        """"""
        # calc relative wind vector
        relative_wind_vector = wind_velocity - drone_velocity
        relative_wind_vector = relative_wind_vector[0:2]
        # calculate angle of relative wind vector
        relative_wind_angle_radians = np.arctan2(relative_wind_vector[1], relative_wind_vector[0])     
        relative_wind_angle_degrees = np.degrees(relative_wind_angle_radians) # Range is -180 to 180
        
        # Adjust angle to be in the range of 0-360 degrees
        if relative_wind_angle_degrees < 0:
            relative_wind_angle_degrees += 360 # 0 N, 90 E, 180 S, 270 W 
        
        if WindModel.DEBUG:
            print(
                "Relative Wind Vector:", relative_wind_vector,
                "\nRelative Windd Degrees:", relative_wind_angle_degrees
                )        

        if relative_wind_angle_degrees <= 45 and relative_wind_angle_degrees > 315:
            # North
            wind_direction = "N"
            return wind_direction
        elif relative_wind_angle_degrees <= 135 and relative_wind_angle_degrees > 45:
            # East
            wind_direction = "E"
            return wind_direction
        elif relative_wind_angle_degrees <= 225 and relative_wind_angle_degrees > 135:        
            # South
            wind_direction = "S"
            return wind_direction
        else:
            # West
            wind_direction = "W"
            return wind_direction
        
    
    def get_direction_of_wind_relative_to_drone(self, drone_name, drone_data):
        """
        :param: drone_data is the dictionary of drone, position, velocity data etc
        """
        
        # Getting velocity data needed to find direction 
        wind = self.wind_vector # (NED)
        drone_data[drone_name] 
        kinematics = drone_data[drone_name]['MultiRotorState'].kinematics_estimated
        drone_velocity = np.array([kinematics.linear_velocity.x_val, kinematics.linear_velocity.y_val, kinematics.linear_velocity.z_val])
        # computing wind direction
        wind_direction = self.calculate_relative_wind_direction(wind, drone_velocity)
        return wind_direction
    

    def get_direction_of_wind_relative_to_swarm(self, drone_names_list, drone_data):
        # Getting velocity data needed to find direction 
        wind = self.wind_vector # (NED)
        
        mean_velocity = np.array([0.0,0.0,0.0])
        drone_list_length = len(drone_names_list)
        for drone_name in drone_names_list:
            drone_data[drone_name] 
            kinematics = drone_data[drone_name]['MultiRotorState'].kinematics_estimated
            mean_velocity += np.array([kinematics.linear_velocity.x_val, kinematics.linear_velocity.y_val, kinematics.linear_velocity.z_val])
        # Compute Mean
        swarm_mean_velocity = mean_velocity/drone_list_length
        # computing wind direction
        wind_direction = self.calculate_relative_wind_direction(wind, swarm_mean_velocity)
        return wind_direction
    

    def set_wind_vector(self, wind_vector):
        self.wind_vector = wind_vector
        

    def get_wind_vector(self):
        return self.wind_vector
        



class QuadController:
    """ Utilized to collect data on quadcopter dynamics """
    

    def __init__(self):
        # Drone Information
        self.drone_names_list = []        
        self.formation_size = 4
        # Setup Environment Parameters
        self.airsim_setup()
        self.initial_position = np.array([])
        wind_vector = [0,-1,0] #(NED), East (0,1,0), North (1,0,0), West (0,-1,0), South (-1, 0, 0)
        # self.wind_direction = "East+" 
        self.wind = WindModel(wind_vector)
    

    def airsim_setup(self):
        """
            Setup the airsim connection and initialize drones
        """
        # start drone client
        self.airsim_client = airsim.MultirotorClient()
        # Check connectivity

        self.airsim_client.confirmConnection()   
        for drone_id in range(1, self.formation_size+1):
            drone_name = "Drone" + str(drone_id)
            self.drone_names_list.append(drone_name)
            self.airsim_client.enableApiControl(True, drone_name)
            self.airsim_client.armDisarm(True, drone_name)
            
    # ################ #
    # Getter Functions #   
    # ################ #

    def get_absolute_poses_NED(self):
        """
            Gets the the global position of all the drones in 
            reference to an absolute global frame of reference.
            Returns a list of all drones ordered from Drone1 - DroneN
        """
        drone_poses_NED = []
        for drone_name in self.drone_names_list:
             # simgetobjectpose returns a pose in the world frame
            drone_pose_WFNED = self.airsim_client.simGetObjectPose(drone_name)
            drone_poses_NED.append( drone_pose_WFNED )
            
        # print("Test: Verifying printing of drones positions in global frame - ", drone_poses_NED)
        return drone_poses_NED
    

    def get_pose_position(self, pose):
        """
        Get the positional information from a pose as numpy array 
        """
        return np.array([pose.position.x_val, pose.position.y_val])
    
    
    def get_pose_altitude(self, pose):
        """
        Get the positional information from a pose as numpy array 
        """
        return np.array([pose.position.z_val])
        
    
    def get_current_drone_positions(self):
        """ Retruns the current drone positions in the NED global coord frame """
        pose_list = self.get_absolute_poses_NED()
        position_matrix = []
        for pose in pose_list:
            position = self.get_pose_position(pose)
            position_matrix.append(position)
        position_matrix = np.array(position_matrix)
        # print(position_matrix)
        return position_matrix
    
    
    def get_desired_position(self):
        desired_final_positions_K = np.array([  
                                      [10, 0], # Drone 1
                                      [0, 0],
                                      [0, 10],
                                      [10, 10]
                                    ])
        return desired_final_positions_K
    

    def get_desired_altitude_NED(self):
        """ Returns Desired NED Altitude """
        desired_altitude = np.array([  
                                -5,
                                -5,
                                -5,
                                -5
                            ])
        return desired_altitude


    def get_drone_altitude(self):
        pose_list = self.get_absolute_poses_NED()
        altitude_list = []
        for pose in pose_list:
            altitude = self.get_pose_altitude(pose)
            print(altitude)
            altitude_list.append(altitude[0])
        altitude_list = np.array(altitude_list)
        return altitude_list
            
    
    # ############### #
    # Data Collection #
    # ############### #

    def copy_drone_swarm_data(self):
        """ 
            Copies data of current drone swarm to be used by power model.
            This is to prevent blocking slow down in the control system.
            General Structure:
                drone_state_dict["drone"] = {
                                        "MultiRotorState": multirotor_state,
                                        "RotorState": rotor_state_info,
                                        "PoseWFNED": drone_pose_WFNED,
                                        "AirDensity": air_density
                                        }
        """
        multirotor_states = None
        rotor_states = None
        drone_pose_WFNED = None
        air_density = None        
        drone_state_dict = {}
        for drone in self.drone_names_list:
            multirotor_state = self.airsim_client.getMultirotorState(vehicle_name=drone)
            rotor_state_info = self.airsim_client.getRotorStates(vehicle_name=drone)
            drone_pose_WFNED = self.airsim_client.simGetObjectPose(drone)
            air_density = self.airsim_client.simGetGroundTruthEnvironment(drone).air_density
            drone_state_dict[drone] = {
                                        "MultiRotorState": multirotor_state,
                                        "RotorState": rotor_state_info,
                                        "PoseWFNED": drone_pose_WFNED,
                                        "AirDensity": air_density
                                        }
        return drone_state_dict            


    def drone_data_collection(self):
        """ Prints out data to the console of Drone1. """
        #drone_name = "Drone1"
        #multirotor_state = self.airsim_client.getMultirotorState(vehicle_name=drone_name)
        #rotor_state_info = self.airsim_client.getRotorStates(vehicle_name=drone_name)
        #drone_pose_WFNED = self.airsim_client.simGetObjectPose(drone_name)
        
        dpm = DronePowerModel()
        # This Power Calculation should be executed once a second
        copied_airsim_state_data = self.copy_drone_swarm_data()
        # State: Hover or Flight
        #power_calculation_thread = Thread(target=dpm.power_model, args=("Flight", "Vee", self.wind_vector,"East+", self.drone_names_list, copied_airsim_state_data))
        #power_calculation_thread.start()
        #power_usage = dpm.swarm_power_consumption_model("Hover", "Vee", self.wind_vector,"East+", self.drone_names_list, copied_airsim_state_data)
        direction_drone_wind = self.wind.get_direction_of_wind_relative_to_drone("Drone1", copied_airsim_state_data)
        direction_swarm_wind = self.wind.get_direction_of_wind_relative_to_swarm(self.drone_names_list, copied_airsim_state_data)
        wind_vector = self.wind.get_wind_vector()
        power_usage = dpm.drone_power_consumption_model("Hover", wind_vector, direction_drone_wind, "Drone1", copied_airsim_state_data)
        return power_usage
        #print("MultiRotor State Information:", multirotor_state)
        #print("************************************************\n")
        #print("Rotor State Information:", rotor_state_info, "\n")
        #print("**********************************************************")
        #print("WNED of drone", drone_pose_WFNED, "\n")
        #print("**********************************************************")
        # print("Drone Energy Usage in Watts", power_usage, "\n")
        #print("**********************************************************")
   
    # ################## #
    # Plotting Functions #
    # ################## #
    def update_plot(self, x, y1, y2):
        """
            Updates plots
        """
        # , self.position_data, self.power_data
        self.iteration_time_step.append(x)
        self.position_data.append(y1)
        self.power_data.append(y2)
        self.line1.set_data(self.iteration_time_step, self.position_data)
        self.line2.set_data(self.iteration_time_step, self.power_data)

        # Adjust limits
        self.position_ax1.relim()
        self.position_ax1.autoscale_view()
        self.power_ax2.relim()
        self.power_ax2.autoscale_view()

        self.fig.canvas.draw()
        plt.pause(0.1)
        self.fig.canvas.flush_events()

    # ############## #
    # Motion Control #
    # ############## #

    def drone_motion_control_alt(self, altitude_control_signal):
        """Assigns a set velocity for the drones to reach their desired destination. """
        #for index, drone_name in enumerate(self.drone_names_list):
        drone_name = "Drone1"
        self.airsim_client.moveByVelocityAsync(0, 0, altitude_control_signal[0], 0.1, vehicle_name=drone_name) # not working
        
        #worker_thread = Thread(target=self.drone_data_collection)
        #worker_thread.start()
        

    def takeoff_swarm(self):
        print(self.drone_names_list)
        for drone_name in self.drone_names_list:
            self.airsim_client.takeoffAsync(vehicle_name=drone_name).join()
       
            
    def drone_motion_control(self, tau_dot):
        """Assigns a set velocity for the drones to reach their desired destination. """
        for index, drone_name in enumerate(self.drone_names_list):
            drone_new_velocity = tau_dot[index] 
            xv = drone_new_velocity[0]
            yv = drone_new_velocity[1] 
            print("velocityL", xv, yv)
            self.airsim_client.moveByVelocityAsync(xv, yv, 0, 0.1, vehicle_name=drone_name) # not working


    def altitude_controller(self):
        # Plotting Setup
        plt.ion()
        plt.grid(True)
        #self.fig, (self.position_ax1, self.power_ax2) = plt.subplots(2,1)
        #self.iteration_time_step, self.position_data, self.power_data = [], [], []
        #self.line1, = self.position_ax1.plot([], [], 'r-', animated=True)
        #self.line2, = self.power_ax2.plot([], [], 'b-', animated=True)
        
        # Set labels and titles for each subplot
        #self.position_ax1.set_xlabel('Time (s)')
        #self.position_ax1.set_ylabel('Energy (Watts)')
        #self.position_ax1.set_title('Energy Output vs. Time')

        #self.power_ax2.set_xlabel('Time (s)')
        #self.power_ax2.set_ylabel('Position (meters)')
        #self.power_ax2.set_title('Position vs. Time')

        # Simulation and Control Parameters
        time_step = 0.1
        iteration = 0
        p_gain = 1
        d_gain = 1
        #self.takeoff_swarm()
        while True:
            # Wait for a time 
            time.sleep(time_step)
            desired_altitude = self.get_desired_altitude_NED()
            #current_drone_pose = self.get_current_drone_positions()
            current_drone_altitude = self.get_drone_altitude()
            print("current drone alti:", current_drone_altitude)
            # PID Altitude Controller 
            error = desired_altitude - current_drone_altitude # Whatever the size of the swarm desired should match
            print("Error", error)
            perror = p_gain * error
            derror = d_gain * (error/time_step)
            control_signal_altitude = perror + derror
            self.drone_motion_control_alt(control_signal_altitude)
            power = self.drone_data_collection()
            iteration = iteration + 1
            #self.update_plot(iteration, current_drone_altitude[0], power)
            
            #plt.clf()
            # Power
            plt.scatter(iteration, power, label='Power Consumption Hover (Watts)', color='red')
            #plt.scatter(5, desired_altitude[0], label='Desired Agent Altitude', color='blue')
            #plt.scatter(current_swarm_centroid[0], current_swarm_centroid[1], label='Current Centroid', color='green')
            #plt.scatter(reference_centroid[0], reference_centroid[1], label='Desired Centroid', color='black')
            #plt.xlim(-25, 25)  # Adjust the x-axis limits if needed
            #plt.ylim(-25, 25)  # Adjust the y-axis limits if needed
            plt.xlabel('Iteration')
            plt.ylabel('Power Consumption Watts')
            plt.title('Power Consumption')
            plt.grid(True)
            # Position
            #plt.scatter(5,  current_drone_altitude[0], label='Current Agent Altitude', color='red')
            #plt.scatter(5, desired_altitude[0], label='Desired Agent Altitude', color='blue')
            #plt.scatter(current_swarm_centroid[0], current_swarm_centroid[1], label='Current Centroid', color='green')
            #plt.scatter(reference_centroid[0], reference_centroid[1], label='Desired Centroid', color='black')
            #plt.xlim(-25, 25)  # Adjust the x-axis limits if needed
            #plt.ylim(-25, 25)  # Adjust the y-axis limits if needed
            #plt.xlabel('X Position')
            #plt.ylabel('Y Position')
            #plt.title('Agent Positions (Iteration {})'.format(iteration))
            #plt.grid(True)
            plt.draw()
            plt.pause(0.1)


if __name__ == "__main__":
    qc = QuadController()
    qc.altitude_controller()